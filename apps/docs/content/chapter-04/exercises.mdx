---
title: "习题与讨论"
description: "4.7 习题与讨论"
---

# 4.7 习题与讨论

> **提示**：以下的部分习题没有标准答案，旨在帮助学习者深入理解 PromptX 的设计哲学，并通过实践掌握角色创建、工具开发和记忆系统的使用方法。

---

## 概念理解题

### 习题 1：上下文鸿沟识别

请使用"四个测试法"分析以下信息是否属于上下文鸿沟：

| 信息 | Google测试 | ChatGPT测试 | 上下文测试 | 特异性测试 | 结论 |
|-----|-----------|------------|-----------|-----------|------|
| React 的 useState 用法 | | | | | |
| 公司的 React 组件命名规范 | | | | | |
| 单元测试的概念 | | | | | |
| 团队要求测试覆盖率 80% | | | | | |
| HTTP 状态码 401 的含义 | | | | | |
| 公司用 418 表示"服务降级" | | | | | |

**要求**：
1. 填写表格，每项用"是"或"否"回答
2. 说明判断依据
3. 对于属于上下文鸿沟的信息，说明应该如何填补（角色/知识/记忆）

<details>
<summary>💡 思考提示</summary>

- Google 测试：能在公开网络上搜到吗？
- ChatGPT 测试：直接问 AI，它能给出正确答案吗？
- 上下文测试：离开你的公司/团队，这个信息还有意义吗？
- 特异性测试：是通用知识还是你们特有的？

</details>

---

### 习题 2：Nuwa 设计哲学理解

Nuwa 的核心理念是"问题比身份重要，目的比工具重要，过程比结果重要"。请分析：

1. **问题比身份重要**：
   - 传统方式："我需要一个 Python 专家"
   - Nuwa 方式：先探索"你想解决什么问题？"
   - 为什么后者更好？举例说明。

2. **目的比工具重要**：
   - 用户说："帮我写一个爬虫"
   - Nuwa 会问："你最终想要什么数据？用来做什么？"
   - 这种追问有什么价值？

3. **过程比结果重要**：
   - 为什么 Nuwa 要通过对话"共创"角色，而不是直接生成？
   - 对话过程中，用户获得了什么额外价值？

---

### 习题 3：Engram 记忆类型选择

请为以下记忆内容选择合适的类型（ATOMIC/LINK/PATTERN），并设计 schema：

| 记忆内容 | 类型 | schema |
|---------|------|--------|
| 用户使用 MacBook Pro M2 | | |
| 用户喜欢简洁的代码风格 | | |
| 用户的调试流程：先加日志，再用断点 | | |
| 项目使用 PostgreSQL 14 数据库 | | |
| 用户认为可读性比性能更重要 | | |
| 用户的需求分析方法：5W1H | | |

<details>
<summary>💡 类型判断提示</summary>

- **ATOMIC（原子）**：具体事实、实体信息
  - 权重：0.4
  - 例：用户名、使用的工具、具体配置

- **LINK（关系）**：偏好关系、因果联系
  - 权重：0.35
  - 例：喜欢/不喜欢、选择 A 因为 B

- **PATTERN（模式）**：流程方法、经验模板
  - 权重：0.25
  - 例：做事的步骤、解决问题的方法论

</details>

---

## 设计与分析题

### 习题 4：使用 Nuwa 创建专业角色

通过与 Nuwa 对话，创建一个"**技术博客写手**"角色。

**要求**：
1. 记录完整的对话过程（至少 5 轮）
2. 展示 Nuwa 如何通过 ISSUE 范式探索需求
3. 分析最终生成角色的四个维度（身份/能力/原则/个性）
4. 测试角色效果：让它写一篇关于"为什么选择 TypeScript"的技术博客

**评估维度**：
- 文章是否符合技术博客的风格？
- 是否体现了角色的专业性？
- 是否遵循了定义的原则？

---

### 习题 5：设计 Luban 工具

设计一个"**代码质量检查工具**"，让 AI 能够分析代码质量。

**功能要求**：
1. 接收代码文件路径或代码内容
2. 分析代码的复杂度、重复度、潜在问题
3. 返回结构化的检查报告

**设计任务**：

1. **接口定义**（description、parameters、returns）：
```yaml
name: code_quality_check
description: # 你的设计
parameters:
  - name: # ...
    type: # ...
    description: # ...
returns:
  type: # ...
  description: # ...
```

2. **使用手册**（manual）：
   - 基本用法示例
   - 参数说明
   - 返回值解释
   - 常见问题

3. **Token 经济学考虑**：
   - 如何避免返回过多数据？
   - 如何实现"索引优于全文"？

---

### 习题 6：记忆网络实践

使用 PromptX 的 recall/remember 功能，完成以下实践：

**场景**：你正在使用 PromptX 帮助你学习一个新的编程框架（如 Vue 3、FastAPI 等）。

**任务**：

1. **建立初始记忆**：
   - 使用 remember 记录 5 条关于这个框架的学习心得
   - 注意选择合适的类型和 schema

2. **验证召回效果**：
   - 使用 recall 尝试不同的关键词
   - 记录哪些关键词能找到相关记忆
   - 分析 schema 设计对召回效果的影响

3. **观察记忆网络**：
   - 使用 DMN 模式（`recall(role, null)`）查看记忆全景
   - 分析记忆之间的关联关系

**提交内容**：
- 5 条记忆的完整内容（content/schema/type/strength）
- recall 测试记录
- 记忆网络的分析总结

---

## 思考探索题

### 习题 7：Chat is All You Need 的哲学思考

PromptX 提出"Chat is All You Need"的世界观。请深入思考：

1. **传统软件范式** vs **Chat 范式**：
   - 传统：人 → 软件界面 → 功能
   - Chat：人 → AI（自然语言）→ 软件
   - 这种转变带来了什么根本性的变化？

2. **AI 作为"用户"的含义**：
   - Luban 说"AI 是用户，人类是指挥官"
   - 这意味着软件/工具的设计思路需要怎样改变？
   - 未来的软件会是什么形态？

3. **"培养"vs"编程"**：
   - 传统 AI 开发：编写代码、训练模型
   - PromptX 方式：像培养人一样培养 AI
   - 这两种方式的本质区别是什么？各自适合什么场景？

---

### 习题 8：Monogent 认知架构分析

Monogent 提出了 Experience-Substrate-Evolution 三元素框架。请分析：

1. **Experience 作为"单子"**：
   - 为什么说 Experience 是认知的"原子单位"？
   - 它与传统的"事件"或"消息"有什么不同？

2. **Computation vs Generation**：
   - 什么任务适合用 Computation 基质处理？
   - 什么任务需要 Generation 基质？
   - 如何决定一个任务用哪种基质？

3. **微演化 vs 宏演化**：
   - 微演化（单次对话内的学习）如何发生？
   - 宏演化（跨会话的知识积累）需要什么机制支持？
   - 人类的学习中有类似的区分吗？

---

## 动手实践题

### 习题 9：构建完整的 PromptX 应用

使用 PromptX 构建一个"**个人知识管理助手**"，它能够：

1. **知识录入**：用户分享学习心得时，自动提取并存储关键知识点
2. **知识召回**：用户提问时，从记忆网络中检索相关知识
3. **知识关联**：发现不同知识点之间的联系
4. **知识复习**：定期提醒用户复习即将遗忘的知识

**实现步骤**：

1. **创建角色**：使用 Nuwa 创建"知识管理专家"角色
2. **设计记忆策略**：
   - 什么内容应该记住？
   - 使用什么类型和 schema？
   - 如何设置 strength？
3. **实现核心功能**：
   - 知识录入流程
   - 召回策略
   - 关联分析
4. **测试与迭代**：
   - 录入 10 条以上知识
   - 测试召回效果
   - 优化 schema 设计

**提交内容**：
- 角色定义
- 记忆策略设计文档
- 至少 10 条记忆样本
- 测试记录和效果分析

---

## 讨论与交流

本章学习过程中遇到问题？想与其他学习者交流心得？

在这里你可以:
- ✅ 分享你创建的角色和工具
- ✅ 讨论记忆网络的最佳实践
- ✅ 交流 PromptX 使用技巧
- ✅ 获得社区的帮助和反馈

---

## 参考文献

[1] PARK J S, O'BRIEN J C, CAI C J, et al. Generative agents: Interactive simulacra of human behavior[C]//Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology. 2023: 1-22.

[2] PACKER C, WOODERS S, LIN K, et al. MemGPT: Towards LLMs as operating systems[J]. arXiv preprint arXiv:2310.08560, 2023.

[3] SUMERS T R, YOON S, HUANG C, et al. Cognitive architectures for language agents[J]. arXiv preprint arXiv:2309.02427, 2023.

---

[⬅️ 上一节：本章小结](4.6-本章小结.md) | [🏠 返回目录](README.md)
